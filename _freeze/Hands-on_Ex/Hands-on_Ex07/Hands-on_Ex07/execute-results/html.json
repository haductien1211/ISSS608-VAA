{
  "hash": "8be922f296ad6d5cd3da05c97fa940df",
  "result": {
    "markdown": "---\ntitle: \"Hands-on Exercise 7 Visualising and Analysing Time-oriented Data\"\nauthor: \"Ha Duc Tien\"\ndate: \"May 30, 2024\"\ndate-modified: \"last-modified\"\nexecute: \n  eval: true\n  echo: true\n  warning: false\n  freeze: true\n---\n\n\n# 1. Overview\n\nBy the end of this hands-on exercise you will be able create the followings data visualisation by using R packages:\n\nplotting a calender heatmap by using ggplot2 functions,\n\nplotting a cycle plot by using ggplot2 function,\n\nplotting a slopegraph\n\nplotting a horizon chart\n\n# 2. Getting started\n\n## 2.1 Installing and launching R packages\n\nWrite a code chunk to check, install and launch the following R packages: scales, viridis, lubridate, ggthemes, gridExtra, readxl, knitr, data.table and tidyverse.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(scales, viridis, lubridate, ggthemes, gridExtra, readxl, knitr, data.table, CGPfunctions, ggHoriPlot, tidyverse)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\npackage 'rootSolve' successfully unpacked and MD5 sums checked\npackage 'lmom' successfully unpacked and MD5 sums checked\npackage 'expm' successfully unpacked and MD5 sums checked\npackage 'Exact' successfully unpacked and MD5 sums checked\npackage 'gld' successfully unpacked and MD5 sums checked\npackage 'productplots' successfully unpacked and MD5 sums checked\npackage 'libcoin' successfully unpacked and MD5 sums checked\npackage 'Formula' successfully unpacked and MD5 sums checked\npackage 'inum' successfully unpacked and MD5 sums checked\npackage 'effectsize' successfully unpacked and MD5 sums checked\npackage 'DescTools' successfully unpacked and MD5 sums checked\npackage 'ggmosaic' successfully unpacked and MD5 sums checked\npackage 'partykit' successfully unpacked and MD5 sums checked\npackage 'sjstats' successfully unpacked and MD5 sums checked\npackage 'CGPfunctions' successfully unpacked and MD5 sums checked\n\nThe downloaded binary packages are in\n\tC:\\Users\\tien_\\AppData\\Local\\Temp\\Rtmpqql2MG\\downloaded_packages\npackage 'ggHoriPlot' successfully unpacked and MD5 sums checked\n\nThe downloaded binary packages are in\n\tC:\\Users\\tien_\\AppData\\Local\\Temp\\Rtmpqql2MG\\downloaded_packages\n```\n:::\n:::\n\n\n## 2.2 The Data\n\nFor the purpose of this hands-on exercise, eventlog.csv file will be used. This data file consists of 199,999 rows of time-series cyber attack records by country.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nattacks <- read_csv(\"data/eventlog.csv\")\n```\n:::\n\n\n## 2.3. Examining the data structure\n\nIt is always a good practice to examine the imported data frame before further analysis is performed.\n\n`kable()` can be used to review the structure of the imported data frame.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nkable(head(attacks))\n```\n\n::: {.cell-output-display}\n|timestamp           |source_country |tz              |\n|:-------------------|:--------------|:---------------|\n|2015-03-12 15:59:16 |CN             |Asia/Shanghai   |\n|2015-03-12 16:00:48 |FR             |Europe/Paris    |\n|2015-03-12 16:02:26 |CN             |Asia/Shanghai   |\n|2015-03-12 16:02:38 |US             |America/Chicago |\n|2015-03-12 16:03:22 |CN             |Asia/Shanghai   |\n|2015-03-12 16:03:45 |CN             |Asia/Shanghai   |\n:::\n:::\n\n\nThere are three columns, namely timestamp, source_country and tz.\n\n-   timestamp field stores date-time values in POSIXct format.\n-   source_country field stores the source of the attack. It is in ISO 3166-1 alpha-2 country code.\n-   tz field stores time zone of the source IP address.\n\n## 2.4 Data Preparation\n\n### Step 1: Deriving weekday and hour of day fields\n\nBefore we can plot the calender heatmap, two new fields namely wkday and hour need to be derived. In this step, we will write a function to perform the task.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmake_hr_wkday <- function(ts, sc, tz) {\n  real_times <- ymd_hms(ts,\n                        tz = tz[1], \n                        quiet = TRUE)\n  dt <- data.table(source_country = sc,\n                   wkday = weekdays(real_times),\n                   hour = hour(real_times))\n  return(dt)\n  }\n```\n:::\n\n\n::: callout-note\n## Note\n\n-   [ymd_hms()](https://lubridate.tidyverse.org/reference/ymd_hms.html) and [hour()](https://lubridate.tidyverse.org/reference/hour.html) are from [lubridate](https://lubridate.tidyverse.org/) package, and\n-   [weekdays()](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/weekdays) is a base R function.\n:::\n\n### Step 2: Deriving the attacks tibble data frame\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwkday_levels <- c('Saturday', 'Friday', \n                  'Thursday', 'Wednesday', \n                  'Tuesday', 'Monday', \n                  'Sunday')\n\nattacks <- attacks %>%\n  group_by(tz) %>%\n  do(make_hr_wkday(.$timestamp, \n                   .$source_country, \n                   .$tz)) %>% \n  ungroup() %>% \n  mutate(wkday = factor(\n    wkday, levels = wkday_levels),\n    hour  = factor(\n      hour, levels = 0:23))\n```\n:::\n\n\n::: callout-note\n## Note\n\nBeside extracting the necessary data into **attacks** data frame, `mutate()` of *dplyr* package is used to convert **wkday** and **hour** fields into *factor* so they’ll be ordered when plotting\n:::\n\nTable below shows the tidy tibble table after processing.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nkable(head(attacks))\n```\n\n::: {.cell-output-display}\n|tz           |source_country |wkday    |hour |\n|:------------|:--------------|:--------|:----|\n|Africa/Cairo |BG             |Saturday |20   |\n|Africa/Cairo |TW             |Sunday   |6    |\n|Africa/Cairo |TW             |Sunday   |8    |\n|Africa/Cairo |CN             |Sunday   |11   |\n|Africa/Cairo |US             |Sunday   |15   |\n|Africa/Cairo |CA             |Monday   |11   |\n:::\n:::\n\n\n# 3 Plotting Calendar Heatmap\n\n## 3.1 Building the Calendar Heatmaps\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngrouped <- attacks %>% \n  count(wkday, hour) %>% \n  ungroup() %>%\n  na.omit()\n\nggplot(grouped, \n       aes(hour, \n           wkday, \n           fill = n)) + \ngeom_tile(color = \"white\", \n          size = 0.1) + \ntheme_tufte(base_family = \"Helvetica\") + \ncoord_equal() +\nscale_fill_gradient(name = \"# of attacks\",\n                    low = \"sky blue\", \n                    high = \"dark blue\") +\nlabs(x = NULL, \n     y = NULL, \n     title = \"Attacks by weekday and time of day\") +\ntheme(axis.ticks = element_blank(),\n      plot.title = element_text(hjust = 0.5),\n      legend.title = element_text(size = 8),\n      legend.text = element_text(size = 6) )\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex07_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n\n::: callout-tip\n## Things to learn from the code chunk\n\n-   a tibble data table called grouped is derived by aggregating the attack by **wkday** and **hour** fields.\n-   a new field called n is derived by using `group_by()` and `count()` functions.\n-   `na.omit()` is used to exclude missing value.\n-   `geom_tile()` is used to plot tiles (grids) at each x and y position. color and size arguments are used to specify the border `color` and line `size` of the tiles.\n-   [theme_tufte()](https://jrnold.github.io/ggthemes/reference/theme_tufte.html) of [ggthemes](https://jrnold.github.io/ggthemes/reference/) package is used to remove unnecessary chart junk. To learn which visual components of default ggplot2 have been excluded, you are encouraged to comment out this line to examine the default plot.\n-   `coord_equal()` is used to ensure the plot will have an aspect ratio of 1:1.\n-   `scale_fill_gradient()` function is used to creates a two colour gradient (low-high).\n:::\n\nThen we can simply group the count by hour and wkday and plot it, since we know that we have values for every combination there’s no need to further preprocess the data.\n\n# 3.2 Building Multiple Calendar Heatmaps\n\n### Step 1: Deriving attack by country object\n\nIn order to identify the top 4 countries with the highest number of attacks, you are required to do the followings:\n\n-   count the number of attacks by country,\n-   calculate the percent of attackes by country, and\n-   save the results in a tibble data frame.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nattacks_by_country <- count(\n  attacks, source_country) %>%\n  mutate(percent = percent(n/sum(n))) %>%\n  arrange(desc(n))\n```\n:::\n\n\n### Step 2: Preparing the tidy data frame\n\nIn this step, you are required to extract the attack records of the top 4 countries from attacks data frame and save the data in a new tibble data frame (i.e. top4_attacks).\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntop4 <- attacks_by_country$source_country[1:4]\ntop4_attacks <- attacks %>%\n  filter(source_country %in% top4) %>%\n  count(source_country, wkday, hour) %>%\n  ungroup() %>%\n  mutate(source_country = factor(\n    source_country, levels = top4)) %>%\n  na.omit()\n```\n:::\n\n\n### Step 3: Plotting the Multiple Calender Heatmap by using ggplot2 package.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(top4_attacks, \n       aes(hour, \n           wkday, \n           fill = n)) + \n  geom_tile(color = \"white\", \n          size = 0.1) + \n  theme_tufte(base_family = \"Helvetica\") + \n  coord_equal() +\n  scale_fill_gradient(name = \"# of attacks\",\n                    low = \"sky blue\", \n                    high = \"dark blue\") +\n  facet_wrap(~source_country, ncol = 2) +\n  labs(x = NULL, y = NULL, \n     title = \"Attacks on top 4 countries by weekday and time of day\") +\n  theme(axis.ticks = element_blank(),\n        axis.text.x = element_text(size = 7),\n        plot.title = element_text(hjust = 0.5),\n        legend.title = element_text(size = 8),\n        legend.text = element_text(size = 6) )\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex07_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n\n# 4. Plotting Cycle Plot\n\nIn this section, you will learn how to plot a cycle plot showing the time-series patterns and trend of visitor arrivals from Vietnam programmatically by using ggplot2 functions.\n\n## 4.1 Data Import\n\nFor the purpose of this hands-on exercise, **arrivals_by_air.xlsx** will be used.\n\nThe code chunk below imports **arrivals_by_air.xlsx** by using `read_excel()` of *readxl* package and save it as a tibble data frame called air.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nair <- read_excel(\"data/arrivals_by_air.xlsx\")\n```\n:::\n\n\n## 4.2 Deriving month and year fields\n\nNext, two new fields called month and year are derived from Month-Year field.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nair$month <- factor(month(air$`Month-Year`), \n                    levels=1:12, \n                    labels=month.abb, \n                    ordered=TRUE) \nair$year <- year(ymd(air$`Month-Year`))\n```\n:::\n\n\n## 4.3 Extracting the target country\n\nNext, the code chunk below is use to extract data for the target country (i.e. Vietnam)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nVietnam <- air %>% \n  select(`Vietnam`, \n         month, \n         year) %>%\n  filter(year >= 2010)\n```\n:::\n\n\n## 4.4 Computing year average arrivals by month\n\nThe code chunk below uses `group_by()` and `summarise()` of dplyr to compute year average arrivals by month.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhline.data <- Vietnam %>% \n  group_by(month) %>%\n  summarise(avgvalue = mean(`Vietnam`))\n```\n:::\n\n\n## 4.5 Plotting the cycle plot\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot() + \n  geom_line(data=Vietnam,\n            aes(x=year, \n                y=`Vietnam`, \n                group=month), \n            colour=\"black\") +\n  geom_hline(aes(yintercept=avgvalue), \n             data=hline.data, \n             linetype=6, \n             colour=\"red\", \n             size=0.5) + \n  facet_grid(~month) +\n  labs(axis.text.x = element_blank(),\n       title = \"Visitor arrivals from Vietnam by air, Jan 2010-Dec 2019\") +\n  xlab(\"\") +\n  ylab(\"No. of Visitors\") +\n  theme_tufte(base_family = \"Helvetica\")\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex07_files/figure-html/unnamed-chunk-15-1.png){width=2304}\n:::\n:::\n\n\n# 5. Plotting Slopegraph\n\nIn this section you will learn how to plot a [slopegraph](https://www.storytellingwithdata.com/blog/2020/7/27/what-is-a-slopegraph) by using R.\n\nBefore getting start, make sure that *CGPfunctions* has been installed and loaded onto R environment. Then, refer to [Using newggslopegraph](https://cran.r-project.org/web/packages/CGPfunctions/vignettes/Using-newggslopegraph.html) to learn more about the function. Lastly, read more about [newggslopegraph()](https://www.rdocumentation.org/packages/CGPfunctions/versions/0.6.3/topics/newggslopegraph) and its arguments.\n\n## 5.1 Data Import\n\nImport the rice data set into R environment by using the code chunk below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrice <- read_csv(\"data/rice.csv\")\n```\n:::\n\n\n## 5.2 Plotting the slopegraph\n\nNext, code chunk below will be used to plot a basic slopegraph as shown below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrice %>% \n  mutate(Year = factor(Year)) %>%\n  filter(Year %in% c(1961, 1980)) %>%\n  newggslopegraph(Year, Yield, Country,\n                Title = \"Rice Yield of Top 11 Asian Counties\",\n                SubTitle = \"1961-1980\",\n                Caption = \"Prepared by: Dr. Kam Tin Seong\")\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex07_files/figure-html/unnamed-chunk-17-1.png){width=672}\n:::\n:::\n",
    "supporting": [
      "Hands-on_Ex07_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}